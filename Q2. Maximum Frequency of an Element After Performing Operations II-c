#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <algorithm>

using namespace std;

class Solution {
public:
    int maxFrequency(vector<int>& nums, int k, int numOperations) {
        int n = nums.size();
        unordered_map<int, int> numberFrequency;
        vector<pair<int, int>> eventPoints;

        // Build frequency map and event points
        for (int num : nums) {
            numberFrequency[num]++;
            eventPoints.push_back({num - k, +1});
            eventPoints.push_back({num + k + 1, -1});
        }

        set<int> uniquePoints;
        for (auto& event : eventPoints) {
            uniquePoints.insert(event.first);
        }
        for (auto& entry : numberFrequency) {
            uniquePoints.insert(entry.first);
        }

        // Sort event points by their value
        sort(eventPoints.begin(), eventPoints.end());

        int currentEventIdx = 0;
        int currentOverlapCount = 0;
        int maxFrequency = 0;

        // Process all unique points and calculate possible max frequency
        for (int point : uniquePoints) {
            // Update overlap count for all events up to current point
            while (currentEventIdx < eventPoints.size() && eventPoints[currentEventIdx].first <= point) {
                currentOverlapCount += eventPoints[currentEventIdx].second;
                currentEventIdx++;
            }

            int currentCount = numberFrequency.count(point) ? numberFrequency[point] : 0;
            int potentialFrequency = currentCount + min(numOperations, currentOverlapCount - currentCount);
            maxFrequency = max(maxFrequency, potentialFrequency);
        }

        return maxFrequency;
    }
};
